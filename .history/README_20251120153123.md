# Semantic-Playwright-Agent (SPA)

> **A Resource-Adaptive, LLM-Driven Web Automation Engine.**

This project is a technical Proof of Concept (PoC) that bridges Large Language Models (LLMs) with Playwright via the Model Context Protocol (MCP). It is designed to execute natural language test instructions against web applications while managing local system resources dynamically.

---

## 1. Core Functionality & Purpose

Unlike traditional recording tools or hard-coded Selenium scripts, this project aims to solve **execution stability** and **instruction flexibility**:

*   **Natural Language Execution**: Instead of writing `page.click('#btn')`, you send "Login as admin". The system uses an LLM to analyze the current DOM snapshot and determine the correct selector dynamically.
*   **Adaptive Concurrency Control**: It implements a feedback-loop scheduler that monitors Node.js Event Loop Lag and OS memory. It throttles browser instances automatically to prevent OOM (Out of Memory) crashes on local machines.
*   **Knowledge-Augmented Execution**: It uses a Vector Database (Qdrant) to retrieve system-specific business rules (e.g., "Order ID must be 10 digits") to guide the LLM's verification logic.

---

## 2. Architecture & Technical Decisions

### 2.1 The "Agent" Loop (MCP Implementation)
We do not generate static Playwright scripts. Instead, we run a live agent loop:
1.  **Observe**: `mcpClient.ts` captures the accessibility tree/HTML snapshot of the current page.
2.  **Think**: `aiParser.ts` sends the snapshot + user instruction to the LLM.
3.  **Act**: The LLM selects a tool from the MCP registry (e.g., `browser_click`, `browser_fill`).
4.  **Verify**: The system captures a post-action snapshot to verify if the state changed (e.g., URL changed, modal appeared).

### 2.2 Adaptive Scheduler (Not just a Queue)
Standard `p-queue` is insufficient for browser automation because browser memory footprints vary wildly.
*   **Mechanism**: A custom controller monitors `perf_hooks.monitorEventLoopDelay`.
*   **Logic**: If event loop lag > 100ms or Free RAM < 20%, the global concurrency slot is forcefully reduced (Circuit Breaker). It slowly recovers when resources free up.

### 2.3 Multi-System Knowledge Isolation (NOT Multi-Tenancy)
*   **Design**: Since the database schema does not support row-level tenant isolation, we implement **Knowledge Base Isolation**.
*   **Implementation**: Each target system (e.g., "SupplyChain", "CRM") gets a dedicated Qdrant Collection (`test_knowledge_{systemName}`). This prevents the LLM from hallucinating rules from System A when testing System B.

---

## 3. Local Deployment Guide

**⚠️ Warning**: This is a personal project. Do not deploy to a public-facing production environment without adding proper authentication and network security layers.

### Prerequisites
*   **Node.js**: v18+
*   **MySQL**: v8.0+ (Must be running locally or accessible)
*   **Docker**: Required for running the Qdrant Vector Database.

### Step 1: Infrastructure Setup

1.  **Start Vector Database (Qdrant)**:
    ```bash
    docker run -d -p 6333:6333 -v $(pwd)/qdrant_storage:/qdrant/storage qdrant/qdrant
    ```

2.  **Prepare SQL Database**:
    *   Log in to your MySQL instance.
    *   Create an empty database named `autoQA` (or whatever you prefer).
    *   *Note: The application will NOT create the database for you.*
    ```sql
    CREATE DATABASE autoQA CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    ```

### Step 2: Configuration

1.  Clone the repository.
2.  Copy the environment file:
    ```bash
    cp .env.example .env
    ```
3.  **Crucial Configuration**: Edit `.env` and fill in your details.
    ```ini
    # Database Connection (Must match Step 1.2)
    DATABASE_URL="mysql://root:your_password@localhost:3306/autoQA"

    # AI Provider (OpenRouter/OpenAI)
    OPENROUTER_API_KEY=sk-xxxx...
    
    # Embedding Service (Aliyun/OpenAI) - Required for RAG
    EMBEDDING_API_KEY=sk-xxxx...
    ```

### Step 3: Installation & Migration

1.  **Install Dependencies**:
    ```bash
    npm install
    ```

2.  **Install Browsers**:
    ```bash
    npx playwright install chromium
    ```

3.  **Database Migration (Create Tables)**:
    *   This step creates the necessary tables (`test_cases`, `users`, etc.) in your MySQL DB.
    ```bash
    npx prisma migrate dev --name init
    ```
    *   *If this fails, check your DATABASE_URL in .env.*

4.  **Seed Initial Data (Optional)**:
    *   Create a default admin user.
    ```bash
    npx tsx scripts/create-admin.ts
    ```

### Step 4: Running the System

You need to run both the backend API and the frontend interface.

**Option A: All-in-one (Dev Mode)**
```bash
npm run dev